-- Scott
-- cons x xs c e = c x xs
-- nil c e = e

-- repeat x = (
--   loop = cons x loop
--   loop
-- )
-- 
-- repeat 5

{-
a + b = (
  add an bn = a an (b an bn)
  add
)

sum l = l (
  sn x y = x + y
  sl x xs = sn x (sum xs)
  sl
) 0

sum (cons 1 (cons 2 (cons 3 nil)))
-}

{-
writeInt 2
id y = y
readInt id
-}

{-
-- additional id is from \foo.foo!
foo = foo (readInt <>)
foo
-}

{-
num = readInt <>
dup y = y y y
dup num
-}

{-
-- until effectful normal form!
id x = x
20 id
-}

{-
-- immediate reflection!
k x = 20 readInt 0
k
-}

-- we require a unit application since arguments are always applied to a token,
-- and otherwise we could not substitute/pass the function without execution
-- should read, read, and write, outputting only the first read
-- k x y = y
-- k (writeInt (readInt <>)) (readInt <>)

-- this works (and should) - great!
-- writeInt (readInt (writeInt (readInt <>)))

-- pure (strict (20 readInt 0))

-- works, but a disconnected dup remains (TODO)
-- x = readInt
-- y = x <>
-- x <>

-- actions are only executed when foo itself is forced
-- foo = if (equal (readInt <>) 41)
--   then (
--     a x = (writeInt 1)
--     a
--   )
--   else (
--     b y = (writeInt 0)
--     b
--   )
-- foo <>

-- now thunking by default
-- if (equal (readInt <>) 42)
--   then (writeInt 1)
--   else (writeInt 0)

foo x = x
foo <>
