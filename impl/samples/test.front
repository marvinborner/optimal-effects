-- Scott
-- cons x xs c e = c x xs
-- nil c e = e

-- repeat x = (
--   loop = cons x loop
--   loop
-- )
-- 
-- repeat 5

{-
a + b = (
  add an bn = a an (b an bn)
  add
)

sum l = l (
  sn x y = x + y
  sl x xs = sn x (sum xs)
  sl
) 0

sum (cons 1 (cons 2 (cons 3 nil)))
-}

{-
writeInt 2
id y = y
readInt id
-}

{-
-- additional id is from \foo.foo!
foo = foo (readInt <>)
foo
-}

{-
num = readInt <>
dup y = y y y
dup num
-}

{-
-- until effectful normal form!
id x = x
20 id
-}

-- we require a unit application since arguments are always applied to a token,
-- and otherwise we could not substitute/pass the function without execution
-- should read, read, and write, outputting only the first read
-- k x y = y
-- k (writeInt (readInt <>)) (readInt <>)

-- this works (and should) - great!
-- writeInt (readInt (writeInt (readInt <>)))

{-
-- immediate reflection!
k x = 20 readInt 0
k
-}

-- pure (strict (20 readInt 0))
