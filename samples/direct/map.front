let fold f x lst = lst [[[fold f (f x $2) $1]]] x

let map f lst = lst [[[[$0 (f $3) (map f $2)]]]] [[$0]]

-- direct construction, no effects possible since under abstraction
let list = [$0 1 [$0 2 [$0 3 [$0 4 [$0 5 [[$0]]]]]]]
let f x = mul x 2
writeInt (fold add 0 (map f list))

-- construction by function, effects possible because of CbV
let nil = [[$0]]
let cons = [[[$0 $2 $1]]]
let list = cons (readInt <>) (cons (readInt <>) (cons (readInt <>) nil))
writeInt (fold add 0 list)
