-- in our interpreter, this will still be determinstic (assuming all evalLang's complete successfully)
-- but try, say, adding a syntax error to a function call or removing returns!
-- evalLang is implemented in such a way that it consumes tokens when failing!

let fac n = race
  (do (
    x <- evalLang "python" "math.factorial" n
    _ <- writeInt x
    return "python!!"
  ))
  (do (
    x <- evalLang "r" "factorial" n
    _ <- writeInt x
    return "r!!"
  ))
  (do (
    x <- evalLang "julia" "factorial" n
    _ <- writeInt x
    return "julia!!"
  )) !

print (fac 12)
